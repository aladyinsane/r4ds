---
title: "R for Data Science notes"
author: "Lauren Chaplinski"
date: "August 2018"
output: html_document
---

Notes from my reading of [*R for Data Science*](http://r4ds.had.co.nz).

### 1-2 Introduction

**Steps in a typical data science project**

1.  Import data
2.  Wrangle data
    i)  Tidy data
        A.  each col is a variable
        B.  each row is an observation
    ii) Transform data
        A.  subset
        B.  create new variables
        C.  calculate summary stats
3.  Generate knowledge
    i)  visualization
    ii) modelling
4.  Communicate results

![  ](data-science-explore.png)

```{r, warning=FALSE}
# install and load packages
if(!require(tidyverse)){
  install.packages("tidyverse", dependencies = TRUE)
  library(tidyverse)
}

if(!require(nycflights13)){
  install.packages("nycflights13", dependencies = TRUE)
  library(nycflights13)
}

if(!require(gapminder)){
  install.packages("gapminder", dependencies = TRUE)
  library(gapminder)
}

if(!require(Lahman)){
  install.packages("Lahman", dependencies = TRUE)
  library(Lahman)
}

if(!require(maps)){
  install.packages("maps", dependencies = TRUE)
  library(maps)
}
```

Use `tidyverse_update()` to check for tidyverse updates.

```{r}
# generate code to recreate a dataset
dput(mtcars)
df.mtcars <- dput(mtcars)

rm(df.mtcars)
```

### 3 Data visualization

#### 3.2 First steps

```{r}
# mpg dataframe
mpg

# plot mpg
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy))
```

`geom_point` adds a layer of points to the plot (scatterplot)

**Basic graphing template**

```
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

##### 3.2.4 Exercises

1.  Run ggplot(data = mpg). What do you see?

```{r}
ggplot(data = mpg)
```

2.  How many rows are in mpg? How many columns?

```{r}
str(mpg)
```

234 rows, 11 columns.

3.  What does the drv variable describe? Read the help for ?mpg to find out.

`drv` describes front wheel, rear wheel, 4 wheel drive.

4.  Make a scatterplot of hwy vs cyl.

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = cyl, y = hwy))
```

5.  What happens if you make a scatterplot of class vs drv? Why is the plot not useful?

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = class, y = drv))
```

#### 3.3 Aesthetic mappings

You can add a third variable to a two dimensional scatterplot by mapping it to an aesthetic. An aesthetic is a visual property of the objects in your plot, e.g. the size, the shape, or the color of your points.

```{r}
# map colors of points to the class variable
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

```{r}
# map sizes of points to the class variable
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```

This throws a warning because mapping an unordered variable (`class`) to an ordered aesthetic (`size`) is not a good idea.

```{r}
# map alpha (transparency) of points to the class variable
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))

# map alpha shape of points to the class variable
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```

SUVs are not plotted because ggplot2 will only use six shapes at a time.

```{r}
# make all points blue
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

##### 3.3.1 Exercises

1.  What's gone wrong with this code? Why are the points not blue?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
```

Color needs to be outside the `aes()` function.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

2.  Which variables in mpg are categorical? Which variables are continuous? (Hint: type `?mpg` to read the documentation for the dataset). How can you see this information when you run mpg?

Categorical: manufacturer, model, year, trans, drv, fl, class
Continuous: displ, cyl, cty, hwy

3.  Map a continuous variable to `color`, `size`, and `shape`. How do these aesthetics behave differently for categorical vs. continuous variables?

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = cty, size = cyl))
```

```{r, eval=FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = cty, size = cyl, shape = hwy))
```

A continuous variable cannot be mapped to shape.

4.  What happens if you map the same variable to multiple aesthetics?

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = displ, shape = class))
```

5.  What does the `stroke` aesthetic do? What shapes does it work with? (Hint: use `?geom_point`)

```{r, eval=FALSE}
?geom_point
vignette("ggplot2-specs")
```

Shapes 21-24 have both stroke color and a fill. The size of the filled part is controlled by `size`, the size of the stroke is controlled by `stroke`.

6.  What happens if you map an aesthetic to something other than a variable name, like `aes(colour = displ < 5)`?

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = cty, y = hwy, color = displ < 5))
```

#### 3.5 Facets

One way to add additional variables is with aesthetics. Another way, particularly useful for categorical variables, is to split your plot into facets, subplots that each display one subset of the data.

Use `facet_wrap()` to facet your plot by a single variable. First argument of `facet_wrap()` should be `~` followed by a variable name (must be discrete).

```{r}
# facet plot by a single variable
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```

Use `facet_grid()` to facet your plot on the combination of two variables. First argument of `facet_grid()` should be two variable names separated by `~`.

```{r}
# facet plot by a two variables
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)

# facet plot by only column dimension (use .)
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(. ~ cyl)
```

##### 3.5.1 Exercises

1.  What happens if you facet on a continuous variable?

You get a facet for each distinct value.

2.  What do the empty cells in plot with `facet_grid(drv ~ cyl)` mean? How do they relate to this plot?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = drv, y = cyl))
```

These represent no overlap of those cyl and drv values.

3.  What plots does the following code make? What does `.` do?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)
```

The . facets against all other variables; in other words, it eliminates the row or column dimension.

4.  Take the first faceted plot in this section:

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```

What are the advantages to using faceting instead of the colour aesthetic? What are the disadvantages? How might the balance change if you had a larger dataset?

It's easier to see the shape of each class, but you can't see the shape of the entire dataset. This might be more beneficial with a larger dataset.

5.  Read `?facet_wrap`. What does `nrow` do? What does `ncol` do? What other options control the layout of the individual panels? Why doesn't `facet_grid()` have `nrow` and `ncol` arguments?

```{r, eval=FALSE}
?facet_wrap
```

nrow and ncol set the number of rows and number of columns of cells to include. facet_grid()'s rows and columns are dictated by the number of distinct values in the faceted variables.

6.  When using `facet_grid()` you should usually put the variable with more unique levels in the columns. Why?

Because most screens are wider than they are tall.

#### 3.6 Geometric objects

A geom is the geometrical object that a plot uses to represent data. Examples: bar charts use bar geoms, line charts use line geoms, boxplots use boxplot geoms, scatterplots use point geoms. To change the geom in a plot, change the geom function. ggplot2 has 30+ geoms and extension packages provide even more (see https://www.ggplot2-exts.org).

```{r}
# point geom
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

# smooth geom
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

Every geom function takes a mapping argument. However, not every aesthetic works with every geom, e.g. you can set the shape of a point, but not of a line. You can, however, set the linetype.

```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))
```

Many geoms (e.g. `geom_smooth()`) use a single geometric object to display multiple rows of data. You can set the `group` aesthetic to a categorical variable to draw multiple objects. However, data is grouped automatically for these geoms whenever you map an aesthetic to a discrete variable (as in the linetype example); typically a better approach because the `group` aesthetic by itself does not add a legend.

```{r}
# no groups
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy))

# groups              
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))

# groups by mapping aesthetic to discrete variable (drv)  
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE
  )
```

Display multiple geoms in the same plot:

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

Less duplicative way to display multiple geoms - pass mappings to `ggplot()` function so you don't have to change x and y variables multiple times:

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

If you put mappings in a geom function, they will extend or overwrite the global mappings for that layer only.

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

Can use this to specify different data for each layer.

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
```

##### 3.6.1 Exercises

1.  What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?

line chart: `geom_line`
boxplot: `geom_boxplot`
histogram: `geom_histogram`
area chart: `geom_area`

2.  Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

3.  What does `show.legend = FALSE` do? What happens if you remove it? Why do you think I used it earlier in the chapter?

It prevents showing the legend in the plot. Removing it will show the legend.

4.  What does the `se` argument to `geom_smooth()` do?

Sets whether to display the confidence interval around the line.

5.  Will these two graphs look different? Why/why not?

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```

No. The first code passes the mapping argument to both geom functions while the second code defines the same arguments in the geom functions themselves.

6.  Recreate the R code necessary to generate the following graphs.

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() +
  geom_smooth(se = FALSE)

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() +
  geom_smooth(mapping = aes(group = drv), se = FALSE)

ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  geom_smooth(se = FALSE)

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(mapping = aes(color = drv)) +
  geom_smooth(se = FALSE)

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(mapping = aes(color = drv)) +
  geom_smooth(mapping = aes(linetype = drv), se = FALSE)

# fill = fill color, color = stroke color
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, fill = drv)) +
  geom_point(shape = 21, color = "white", size = 4, stroke = 3)
```

#### 3.7 Statistical transformations

Many graphs, like scatterplots, plot the raw values of your dataset. Other graphs, like bar charts, calculate new values, such as counts/frequencies.

**New values calculated by graphs**

  - bar charts, histograms, and frequency polygons bin your data and then plot bin counts
  - smoothers fit a model to your data and then plot predictions from the model
  - boxplots compute a robust summary of the distribution and then display a specially formatted box
  
You can learn which stat a geom uses by inspecting the default value for the `stat` argument. For example, `geom_bar()` uses `stat_count()`. These can be used more or less interchangably. Every geom has a default stat and every stat has a default geom.

```{r}
# this produces the same graph...
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))

# ...as this
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))
```

3 reasons to use a stat explicitly:

1.  override the default stat

```{r}
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)

# change from count to identity to map height of bars to raw values of y
ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")
```

2.  override the default mapping from transformed variables to aesthetics

```{r}
# display a bar chart of proportion instead of count
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
```

3.  draw greater attention to the statistical transformation in your code

```{r}
# summarize the y values for each unique x value
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  )
```

##### 3.7.1 Exercises

1.  What is the default geom associated with `stat_summary()`? How could you rewrite the previous plot to use that geom function instead of the stat function?

The default geom is `geom_pointrange`.

```{r}
ggplot(data = diamonds) + 
  geom_pointrange(mapping = aes(x = cut, y = depth),
                  stat = "summary",
                  fun.ymin = min,
                  fun.ymax = max,
                  fun.y = median)
```

2.  What does `geom_col()` do? How is it different to `geom_bar()`?

`geom_bar()` makes the height of the bar proportional to the number of cases in each group. `geom_col()` makes the height of the bars represent values in the data.

3.  Most geoms and stats come in pairs that are almost always used in concert. Read through the documentation and make a list of all the pairs. What do they have in common?

`geom_area()` - `stat_identity()`  
`geom_bar()` - `stat_count()`  
`geom_bin2d()` - `stat_bin2d()`  
`geom_blank()` - `stat_identity()`  
`geom_boxplot()` - `stat_boxplot()`  
`geom_col()` - `stat_count()`  
`geom_contour()` - `stat_contour()`  
`geom_count()` - `stat_sum()`  
`geom_crossbar()` - `stat_identity()`  
`geom_curve()` - `stat_identity()`  
`geom_density()` - `stat_density()`  
`geom_density_2d()` - `stat_density_2d()`  
`geom_errorbar()` - `stat_identity()`  
`geom_errorbarh()` - `stat_identity()`  
`geom_freqpoly()` - `stat_bin()`  
`geom_hex()` - `stat_bin_hex()`  
`geom_label()` - `stat_identity()`  
`geom_line()` - `stat_identity()`  
`geom_linerange()` - `stat_identity()`  
`geom_map()` - `stat_identity()`  
`geom_point()` - `stat_identity()`  
`geom_pointrange()` - `stat_identity()`  
`geom_polygon()` - `stat_identity()`  
`geom_qq()` - `stat_qq()`  
`geom_quantile()` - `stat_quantile()`  
`geom_raster()` - `stat_identity()`  
`geom_rect()` - `stat_identity()`  
`geom_ribbon()` - `stat_identity()`  
`geom_rug()` - `stat_identity()`  
`geom_segment()` - `stat_identity()`  
`geom_sf()` - `stat_sf()`  
`geom_smooth()` - `stat_smooth()`  
`geom_spoke()` - `stat_identity()`  
`geom_step()` - `stat_identity()`  
`geom_text()` - `stat_identity()`  
`geom_tile()` - `stat_identity()`  
`geom_violin()` - `stat_ydensity()`

4.  What variables does `stat_smooth()` compute? What parameters control its behaviour?

`stat_smooth()` computes `y` (predicted value), `ymin` (lower end of confidence interval), `ymax` (upper end of confidence interval), and `se` (standard error). The parameters `method`, `formula`, `n`, `span`, and `fullrange`.

5.  In our proportion bar chart, we need to set `group = 1`. Why? In other words what is the problem with these two graphs?

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop..))

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..))
```

The `group` argument must be set to 1 to consider the entire data set as a single group to calculate the proportion of each value of `x`.

#### 3.8 Position adjustments

Add color to bar charts.

```{r}
# color outline of bars
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, color = cut))

# color bars
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```

Stacking is performed automatically by `position` argument. There are 4 other options: "identity", "dodge" or "fill".

  - `position = "identity"`: not very useful for solid bars because they will overlap. Must make the bars slightly transparent (set `alpha`) or transparent (set `fill = NA`).

```{r}
# slightly transparent bars
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")

# unfilled bars
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")
```

  - `position = "fill"`: like stacking, but each set of stacked bars is the same height; makes it easier to compare proportions across groups.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
```

  - `position = "dodge"`: overlapping objects beside one another; makes it easier to compare individual values.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

  - `position = "jitter"`: not useful for bar charts, but for scatterplots (`geom_point()`). Adds a small amount of random noise to each point to reduce overplotting and make it easier to see where the mass of data are.
  
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")

# can also be written using this shorthand
ggplot(data = mpg) +
  geom_jitter(mapping = aes(x = displ, y = hwy))
```

##### 3.8.1 Exercises

1.  What is the problem with this plot? How could you improve it?

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_point()
```

The problem is it suffers from overplotting. It could be improved using `geom_jitter()`.

```{r}
# add random noise to points
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_jitter()
```

2.  What parameters to `geom_jitter()` control the amount of jittering?

`width` and `height`.

3.  Compare and contrast `geom_jitter()` with `geom_count()`.

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_count()
```

`geom_jitter()` adds random noise to each point so points don't overlap. `geom_count()` counts the number of points at each position and plots different size points for higher counts.

4.  What's the default position adjustment for `geom_boxplot()`? Create a visualisation of the `mpg` dataset that demonstrates it.

The default position adjustment for `geom_boxplot()` is dodge.

```{r}
ggplot(data = mpg) +
  geom_boxplot(mapping = aes(x = drv, y = hwy, fill = class))
```

#### 3.9 Coordinate systems

The default coordinate system is the Cartesian coordinate system where the x and y positions act independently to determine the location of each point. A few other coordinate systems are occasionally used.

```{r}
# coord_flip() switches x & y axes
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot() +
  coord_flip()

# coord_quickmap() sets the aspect ratio correctly for maps
nz <- map_data("nz")

ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  coord_quickmap()

# coord_polar() uses polar coordinates
bar <- ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = cut, fill = cut), 
    show.legend = FALSE,
    width = 1
  ) + 
  theme(aspect.ratio = 1) +
  labs(x = NULL, y = NULL)

bar + coord_polar()
```

##### 3.9.1 Exercises

1.  Turn a stacked bar chart into a pie chart using `coord_polar()`.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = 1, fill = cut)) +
  labs(x = NULL, y = NULL) +
  coord_polar(theta = "y")
```

2.  What does `labs()` do? Read the documentation.

`labs()` is used to modify axis, legend, and plot labels.

3.  What's the difference between `coord_quickmap()` and `coord_map()`?

`coord_map()` projects a portion of the earth onto a flat 2D plane. Generally map projections do not preserve straight lines, so this requires considerable computation. `coord_quickmap()` is a quick approximation that *does* preserve straight lines which works best for smaller areas closer to the equator.

4.  What does the plot below tell you about the relationship between city and highway mpg? Why is `coord_fixed()` important? What does `geom_abline()` do?

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_point() + 
  geom_abline() +
  coord_fixed()
```

There is a strong positive linear relationship between highway mpg and city mpg. Using the default value for `coord_fixed()` (`ratio = 1`) ensures that one unit on the x-axis is the same length as one unit on the y-axis.

`geom_abline()` adds a diagonal reference line. Since the `xintercept`, `yintercept`, `slope`, and `intercept` parameters are not defined, the position of the line is combined with the default aesthetic mapping at the top level of the plot.

#### 3.10 The layered grammar of graphics

**More advanced graphing template**

```
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>
```

The seven parameters in the template compose the grammar of graphics, a formal system for building plots based on the insight that you can uniquely describe any plot as a combination of:

1.  a dataset,
2.  a geom,
3.  a set of mappings,
4.  a stat,
5.  a position adjustment,
6.  a coordinate system, and
7.  a faceting scheme.

### 4 Workflow: basics

#### 4.2 What's in a name?

*These notes do not actually follow R4DS, but [Google's R Style Guide](https://google.github.io/styleguide/Rguide.xml) instead.*

The preferred form for variable names is all lower case letters and words separated with dots (`variable.name`). Function names have initial capital letters and no dots (`FunctionName`). Function names should be verbs (`CalculateAvgClicks`). Constants are named like functions but with an initial `k`. Don't use underscores (`_`) or hyphens (`-`).

```{r}
# assign a value to an object
this.is.a.really.long.name <- 2.5
```

To autocomplete, type "this" and press tab. To list all commands typed beginning with "this", type "this" then Ctrl+up.

#### 4.3 Calling functions

R functions are called like this:

```
function_name(arg1 = val1, arg2 = val2, ...)
```

```{r}
# seq() function makes a regular sequence of numbers
seq(1, 10)

# surround assignment with () to print result
(y <- seq(1, 10, length.out = 5))
```

#### 4.4 Practice

1.  Why does this code not work?

```{r}
my_variable <- 10
my_variable
```

This does actually work for me; however, it appears there is supposed to be a typo in `my_variable` (should be i instead of i).

2.  Tweak each of the following R commands so that they run correctly:

```{r}
library(tidyverse)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

filter(mpg, cyl == 8)
filter(diamonds, carat > 3)
```

3.  Press Alt + Shift + K. What happens? How can you get to the same place using the menus?

A list of keyboard shortcuts appears. This can be accessed under Help > Keyboard Shortcuts Help.

### 5 Data transformation

#### 5.1 Introduction & prerequisites

This chapter will teach you how to transform your data using the dplyr package. The dplyr package overwrites some functions in base R; to use the base version of these functions after loading dplyr, you'll need to use their full names, e.g. `stats::filter()` and `stats::lag()`.

##### 5.1.2 nycflights13

We'll use `nycflights13::flights` to explore basic data manipulation verbs of dplyr.

```{r}
# this prints differently than other dataframes because it's a tibble
flights
```

The columns are described by the type of variable:

| abbrv | type      |
|:-----:|:---------:|
| int   | integer   |
| dbl   | double    |
| chr   | string    |
| dttm  | date-time |
| lgl   | logical   |
| fctr  | factor    |
| date  | date      |

##### 5.1.3 dplyr basics

Five key functions solve most data manipulation needs:

* `filter()` - pick observations by their values
* `arrange()` - reorder rows
* `select()` - pick variables by their names
* `mutate()` - create new variables with functions of existing variables
* `summarize()` - collapse many values down to a single summary

All of the above can be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group.

These all work similarly:

1.  First argument is a data frame.
2.  Subsequent arguments describe what to do with the data frame using variable names.
3.  Result is a new data frame.

#### 5.2 Filter rows with `filter()`

```{r}
# select all flights on January 1st, assign to jan1, and print
(jan1 <- filter(flights, month == 1, day == 1))
```

##### 5.2.1 Comparisons

Comparison operators: `>`, `>=`, `<`, `<=`, `!=`, and `==`.

Be cautious of floating point numbers. Use `near()` instead of `==`.

```{r}
sqrt(2) ^ 2 == 2
near(sqrt(2) ^ 2, 2)

1 / 49 * 49 == 1
near(1 / 49 * 49, 1)
```

##### 5.2.2 Logical operators

Multiple arguments to `filter()` are combined with "and": every expression must be true in order for a row to be included in the output. Other types of combinations will have to be specified using Boolean operators: `&` is "and", `|` is "or", and `!` is "not".

![`x` is the left circle and `y` is the right circle. The shaded portion indicates what is returned.](transform-logical.png)

```{r}
# all flights departing in november or december
filter(flights, month == 11 | month == 12)
```

Another way of selecting rows is `x %in% y`. This will select every row where `x` is one of the values in `y`.

```{r}
# all flights departing in november or december
filter(flights, month %in% c(11, 12))
```

**De Morgan's law**

`!(x & y)` is the same as `!x | !y`  
`!(x | y)` is the same as `!x & !y`  

Can be useful in simplifying complicated subsetting.

```{r}
# find flights that weren't delayed (on arrival or departure) by more than two hours - either of these work
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
```

##### 5.2.3 Missing values

`NA` represents an unknown value. Missing values are "contagious" - almost any operation involving an unknown value will also be unknown.

```{r}
NA > 5
NA + 10
NA / 2
NA == NA

# use is.na() to determine if a value is NA
x <- NA
is.na(x)
```

`filter()` excludes `NA` values; they must be requested explicitly if you want to preserve them.

```{r}
df <- tibble(x = c(1, NA, 3))
filter(df, is.na(x) | !is.na(x))
```

##### 5.2.4 Exercises

1.  Find all flights that:

* Had an arrival delay of two or more hours

```{r}
filter(flights, arr_delay >= 120)
```

* Flew to Houston (IAH or HOU)

```{r}
filter(flights, dest %in% c("IAH", "HOU"))
```

* Were operated by United, American, or Delta

```{r}
filter(flights, carrier %in% c("AA", "UA", "DL"))
```

* Departed in summer (July, August, and September)

```{r}
filter(flights, month %in% c(7, 8, 9))
```

* Arrived more than two hours late, but didn't leave late

```{r}
filter(flights, arr_delay > 120 & dep_delay <= 0)
```

* Were delayed by at least an hour, but made up over 30 minutes in flight

```{r}
filter(flights, dep_delay >= 60, arr_delay < 30)
```

* Departed between midnight and 6am (inclusive)

```{r}
filter(flights, dep_time >=0 & dep_time <= 600)
```

2.  Another useful dplyr filtering helper is `between()`. What does it do? Can you use it to simplify the code needed to answer the previous challenges?

This is a shortcut for `x >= left & x <= right` and its usage is `between(x, left, right)`. It can be used to simplify the code to return flights that departed between midnight and 6am (inclusive):

```{r}
# use between() to simplify code
filter(flights, between(dep_time, 0, 600))
```

3.  How many flights have a missing `dep_time`? What other variables are missing? What might these rows represent?

```{r}
filter(flights, is.na(dep_time))
```

8,255 flights have missing `dep_time` values. These rows are also missing values for `dep_delay`, `arr_time`, `arr_delay`, and `air_time`. These rows might represent canceled flights.

4.  Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing? Why is `FALSE & NA` not missing? Can you figure out the general rule? (`NA * 0` is a tricky counterexample!)

`NA ^ 0` is not missing because any value raised to the power of 0 equals 1. `NA | TRUE` is not missing because if either value is `TRUE`, the expression evaluates to `TRUE`. `FALSE & NA` is not missing because if either value is `FALSE`, the expression evalutes to `FALSE`. The general rule appears to be if the outcome of the expression can be deduced based on the non-`NA` value alone, that outcome will be returned.

#### 5.3 Arrange rows with `arrange()`

`arrange()` changes the order of rows. It takes as arguments a data frame and a set of column names or expressions to order by. If more than one column is provided, the additional columns are used to break ties. Missing values are always sorted at the end.

```{r}
arrange(flights, year, month, day)

# use desc() to sort in decending order
arrange(flights, desc(dep_delay))
```

##### 5.3.1 Exercises

1.  How could you use `arrange()` to sort all missing values to the start? (Hint: use `is.na()`).

```{r}
arrange(flights, desc(is.na(dep_time)), desc(is.na(dep_delay)), desc(is.na(arr_time)),
        desc(is.na(arr_delay)), desc(is.na(tailnum)), desc(is.na(air_time)))
```

2.  Sort `flights` to find the most delayed flights. Find the flights that left earliest.

```{r}
# most delayed
arrange(flights, desc(dep_delay), desc(arr_delay))

# earliest departures
arrange(flights, dep_delay)
```

3.  Sort `flights` to find the fastest flights.

```{r}
arrange(flights, air_time)
```

4.  Which flights travelled the longest? Which travelled the shortest?

```{r}
# longest distance
arrange(flights, desc(distance))

# shortest distance
arrange(flights, distance)
```

#### 5.4 Select columns with `select()`

`select()` allows you to subset based on variable names.

```{r}
# columns by name
select(flights, year, month, day)

# all columns between year and day inclusive
select(flights, year:day)

# all columns except those from year to day inclusive
select(flights, -(year:day))
```

Helper functions that can be used within `select()`:

* `starts_with("abc")` - matches names that begin with "abc"  
* `ends_with("xyz")` - matches names that end with "xyz"  
* `contains("ijk")` - matches names that contain "ijk"  
* `matches("(.)\\1")` - selects variables that match a regular expression; this example matches variables that contain repeated characters  
* `num_range("x", 1:3)` - matches x1, x2 and x3  

`select()` can be used to rename variables; however, `rename()` is better as `select()` drops variables that aren't explicitly mentioned.

```{r}
rename(flights, tail_num = tailnum)
```

`everything()` helper is useful for moving a few variables to the start of the data frame.

```{r}
select(flights, time_hour, air_time, everything())
```

##### 5.4.1 Exercises

1.  Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights`.

```{r}
select(flights, dep_time, dep_delay, arr_time, arr_delay)
select(flights, starts_with("dep"), starts_with("arr"))
select(flights, -(year:day), -(sched_dep_time), -(sched_arr_time), -(carrier:time_hour))
```

2.  What happens if you include the name of a variable multiple times in a `select()` call?

```{r}
select(flights, year, air_time, year)
```

The repeated variable name is ignored.

3.  What does the `one_of()` function do? Why might it be helpful in conjunction with this vector?

```{r}
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
```

`one_of()` is used to select variables in a vector. It could be used in conjunction with the above vector to select those variables.

```{r}
select(flights, one_of(vars))
```

4.  Does the result of running the following code surprise you? How do the select helpers deal with case by default? How can you change that default?

```{r}
select(flights, contains("TIME"))
```

Yes. The select helpers ignore case by default. This can be changed by including `ignore.case = FALSE` as an argument to the helper function.

#### 5.5 Add new variables with `mutate()`

`mutate()` adds new columns that are functions of existing columns.

```{r}
# create smaller data frame
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)

mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)

# can immediately refer to created columns
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

`transmute()` keeps only the newly created variables.

```{r}
transmute(flights,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

##### 5.5.1 Useful creation functions

Many functions can be used with `mutate()`. The function must be vectorized, meaning it must take a vector of values as input and return a vector with the same number of values as output.

**Frequently used functions**

* Arithmetic operators: `+`, `-`, `*`, `/`, `^`. Vectorized using "recycling rules". Useful when one of the arguments is a single number, e.g. `air_time / 60`, `hours * 60 + minute`. Also useful with aggregate functions, e.g. `x / sum(x)`, `y - mean(y)`.  

* Modular arithmetic: `%/%` (integer division) and `%%` (remainder) which allows integers to be broken up into pieces.  

```{r}
# compute hour and min from dep_time
transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)
```

* Logs: `log()`, `log2()`, `log10()`. Logarithms are useful for dealing with data that ranges across multiple orders of magnitude. They also convert multiplicative relationships to additive. `log2()` is easiest to interpret: a difference of 1 on the log scale corresponds to doubling on the original scale and a difference of -1 corresponds to halving.  

* Offsets: `lead()` and `lag()` refer to leading or lagging values; can be used to compute running differences (e.g. `x - lag(x)`) or find when values change (`x != lag(x)`). Most useful in conjunction with `group_by()`.  

```{r}
(x <- 1:10)
lag(x)
lead(x)
```

* Cumulative and rolling aggregates: R provides functions for running sums, products, mins and maxes: `cumsum()`, `cumprod()`, `cummin()`, `cummax()`; and dplyr provides `cummean()` for cumulative means. RcppRoll package provides rolling aggregates.  

```{r}
cumsum(x)
cummean(x)
```

* Logical comparisons: `<`, `<=`, `>`, `>=`, `!=`.  

* Ranking: there are a number of ranking functions, but start with `min_rank()` which does usual type of ranking (e.g. 1st, 2nd, 2nd, 4th). The default gives smallest values the small ranks; use `desc(x)` to give the largest values the smallest ranks. Other ranking variants are `row_number()`, `dense_rank()`, `percent_rank()`, `cume_dist()`, `ntile()`.  

```{r}
y <- c(1, 2, 2, NA, 3, 4)
min_rank(y)
min_rank(desc(y))
row_number(y)
dense_rank(y)
percent_rank(y)
cume_dist(y)
```

##### 5.5.2 Exercises

1.  Currently `dep_time` and `sched_dep_time` are convenient to look at, but hard to compute with because they're not really continuous numbers. Convert them to a more convenient representation of number of minutes since midnight.

```{r}
transmute(flights,
  dep_time,
  sched_dep_time,
  dep_min_since_midn = ((dep_time %/% 100) * 60) + (dep_time %% 100),
  sched_dep_min_since_midn = ((sched_dep_time %/% 100) * 60) + 
    (sched_dep_time %% 100)
)
```

2.  Compare `air_time` with `arr_time - dep_time`. What do you expect to see? What do you see? What do you need to do to fix it?

```{r}
transmute(flights,
  air_time,
  arr_less_dep_time = arr_time - dep_time
)
```

`air_time` should be equal to `arr_time - dep_time`; however, they are not. `arr_time` and `dep_time` need to be converted to minutes from midnight before using them in calculations. Also, the times are expressed in local time, so it may be that time zone adjustments should be applied.

```{r}
transmute(flights,
  air_time,
  arr_time,
  dep_time,
  arr_time_mfm = ((arr_time %/% 100) * 60) + (arr_time %% 100),
  dep_time_mfm = ((dep_time %/% 100) * 60) + (dep_time %% 100),
  arr_less_dep_time = arr_time_mfm - dep_time_mfm
)
```

3.  Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you expect those three numbers to be related?

`dep_time` - `sched_dep_time` should equal `dep_delay` after converting `sched_dep_time` and `dep_time` to minutes from midnight.

```{r}
transmute(flights,
  dep_time,
  sched_dep_time,
  dep_delay,
  dep_mfm = ((dep_time %/% 100) * 60) + (dep_time %% 100),
  sched_dep_mfm = ((sched_dep_time %/% 100) * 60) + (sched_dep_time %% 100),
  delay_mfm = dep_mfm - sched_dep_mfm
)
```

4.  Find the 10 most delayed flights using a ranking function. How do you want to handle ties? Carefully read the documentation for `min_rank()`.



5.  What does `1:3 + 1:10` return? Why?

```{r}
1:3 + 1:10
```

R "recycles" the shorter vector to the length of the longer vector. This becomes $1+1, 2+2, 3+3, 1+4, 2+5, 3+6, 1+7, 2+8, 3+9, 1+10$.

6.  What trigonometric functions does R provide?
